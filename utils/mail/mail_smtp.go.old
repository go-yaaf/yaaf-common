package mail

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io"
	"strconv"

	"gopkg.in/gomail.v2"
)

// region SMTP Mail Message --------------------------------------------------------------------------------------------

// smtpMailMessage is an implementation of the IMailMessage interface for sending email via SMTP.
type smtpMailMessage struct {
	client      *smtpMailClient
	from        string
	to          []string
	cc          []string
	bcc         []string
	subject     string
	body        string
	html        string
	mime        string
	template    TemplateName
	attachments []MailMessageAttachment
	variables   map[string]string
}

// From sets the sender's email address.
func (m *smtpMailMessage) From(from string) IMailMessage {
	m.from = from
	return m
}

// To sets the recipients' email addresses.
func (m *smtpMailMessage) To(to []string) IMailMessage {
	m.to = to
	return m
}

// Cc sets the CC recipients' email addresses.
func (m *smtpMailMessage) Cc(cc []string) IMailMessage {
	m.cc = cc
	return m
}

// Bcc sets the BCC recipients' email addresses.
func (m *smtpMailMessage) Bcc(bcc []string) IMailMessage {
	m.bcc = bcc
	return m
}

// Subject sets the email's subject line.
func (m *smtpMailMessage) Subject(subject string) IMailMessage {
	m.subject = subject
	return m
}

// Body sets the plain text body of the email.
func (m *smtpMailMessage) Body(body string) IMailMessage {
	m.body = body
	return m
}

// HtmlBody sets the HTML body of the email.
func (m *smtpMailMessage) HtmlBody(html string) IMailMessage {
	m.html = html
	return m
}

// Attachments sets the list of attachments for the email.
func (m *smtpMailMessage) Attachments(attachments []MailMessageAttachment) IMailMessage {
	m.attachments = attachments
	return m
}

// AddTo adds one or more recipients to the To list.
func (m *smtpMailMessage) AddTo(to ...string) IMailMessage {
	m.to = append(m.to, to...)
	return m
}

// AddCc adds one or more recipients to the CC list.
func (m *smtpMailMessage) AddCc(cc ...string) IMailMessage {
	m.cc = append(m.cc, cc...)
	return m
}

// AddBcc adds one or more recipients to the BCC list.
func (m *smtpMailMessage) AddBcc(bcc ...string) IMailMessage {
	m.bcc = append(m.bcc, bcc...)
	return m
}

// AddAttachments adds one or more attachments to the email.
func (m *smtpMailMessage) AddAttachments(attachments ...MailMessageAttachment) IMailMessage {
	m.attachments = append(m.attachments, attachments...)
	return m
}

// Attach adds attachments from a list of file paths.
func (m *smtpMailMessage) Attach(paths ...string) IMailMessage {
	for _, path := range paths {
		if att, err := getAttachment(path); err == nil {
			m.AddAttachments(att)
		}
	}
	return m
}

// Send sends the email using the SMTP client.
func (m *smtpMailMessage) Send() error {
	return m.client.send(m)
}

// endregion

// region SMTP Mail Client ---------------------------------------------------------------------------------------------

// smtpMailClient is an implementation of the IMailClient interface that sends email via SMTP.
type smtpMailClient struct {
	host     string
	port     int
	user     string
	password string
	useTls   bool
}

// newSmtpMailClient creates a new smtpMailClient.
func newSmtpMailClient(host, port, usr, pwd string, tls bool) IMailClient {
	p, err := strconv.Atoi(port)
	if err != nil {
		p = 587 // Default SMTP port
	}
	return &smtpMailClient{
		host:     host,
		port:     p,
		user:     usr,
		password: pwd,
		useTls:   tls,
	}
}

// MailUsr returns the username used for authentication.
func (c *smtpMailClient) MailUsr() string {
	return c.user
}

// CreateTextMessage creates a new plain text message.
func (c *smtpMailClient) CreateTextMessage() IMailMessage {
	return &smtpMailMessage{
		client: c,
		mime:   "text/plain",
	}
}

// CreateHtmlMessage creates a new HTML message.
func (c *smtpMailClient) CreateHtmlMessage() IMailMessage {
	return &smtpMailMessage{
		client: c,
		mime:   "text/html",
	}
}

// CreateJsonMessage is not supported for SMTP and returns a plain text message instead.
func (c *smtpMailClient) CreateJsonMessage() IMailMessage {
	return c.CreateTextMessage()
}

// CreateTemplateMessage is not supported for SMTP and returns a plain text message instead.
func (c *smtpMailClient) CreateTemplateMessage(template TemplateName, variables map[string]string) IMailMessage {
	return c.CreateTextMessage()
}

// send constructs and sends the email using the gomail library.
func (c *smtpMailClient) send(m *smtpMailMessage) error {
	msg := gomail.NewMessage()
	msg.SetHeader("From", m.from)
	msg.SetHeader("To", m.to...)
	if len(m.cc) > 0 {
		msg.SetHeader("Cc", m.cc...)
	}
	if len(m.bcc) > 0 {
		msg.SetHeader("Bcc", m.bcc...)
	}
	msg.SetHeader("Subject", m.subject)

	// Set body based on mime type
	if m.mime == "text/html" {
		msg.SetBody("text/html", m.html)
		if m.body != "" {
			msg.AddAlternative("text/plain", m.body)
		}
	} else {
		msg.SetBody("text/plain", m.body)
	}

	// Add attachments
	for _, attachment := range m.attachments {
		if err := c.attach(msg, attachment); err != nil {
			return fmt.Errorf("failed to attach file %s: %w", attachment.FileName, err)
		}
	}

	d := gomail.NewDialer(c.host, c.port, c.user, c.password)
	d.TLSConfig = nil // Explicitly disable TLS by default, enable if useTls is true
	if c.useTls {
		// In a real scenario, you would configure a proper tls.Config
		// For simplicity, we are not doing it here.
	}

	return d.DialAndSend(msg)
}

// attach adds an attachment to the gomail message.
func (c *smtpMailClient) attach(msg *gomail.Message, att MailMessageAttachment) error {
	// The attachment content can be provided as a base64 string or from a file path.
	if att.Content == "" && att.FileName != "" {
		// If content is empty, assume FileName is a path and attach the file directly.
		msg.Attach(att.FileName)
		return nil
	}

	// If content is provided, decode it and attach it.
	if att.Content != "" {
		content, err := base64.StdEncoding.DecodeString(att.Content)
		if err != nil {
			return fmt.Errorf("failed to decode base64 attachment content: %w", err)
		}

		f := func(w io.Writer) error {
			_, err := io.Copy(w, bytes.NewReader(content))
			return err
		}
		msg.Attach(att.FileName, gomail.SetCopyFunc(f))
		return nil
	}

	return fmt.Errorf("attachment %s has no content or file path", att.FileName)
}

// endregion
